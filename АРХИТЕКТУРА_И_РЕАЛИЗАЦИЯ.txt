================================================================================
АРХИТЕКТУРА И РЕАЛИЗАЦИЯ ПРОЕКТА "GAME MAIL API"
Система внутриигровой почты для многопользовательской игры
================================================================================

1. АРХИТЕКТУРА ПРОЕКТА
================================================================================

1.1. Тип архитектуры
--------------------------------------------------------------------------------
Проект использует СЛОИСТУЮ АРХИТЕКТУРУ (Layered Architecture) с элементами 
Clean Architecture и паттерна Repository.

Основные принципы:
- Разделение ответственности между слоями
- Инверсия зависимостей (Dependency Injection через FastAPI Depends)
- Разделение бизнес-логики и доступа к данным
- Использование ORM для абстракции работы с БД

1.2. Структура слоев
--------------------------------------------------------------------------------

┌─────────────────────────────────────────────────────────────────┐
│                    API LAYER (Контроллеры)                      │
│  app/api/endpoints/auth.py, messages.py                         │
│  - Обработка HTTP запросов                                      │
│  - Валидация входных данных через Pydantic                      │
│  - Возврат HTTP ответов                                         │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                  SERVICES LAYER (Бизнес-логика)                 │
│  app/services/auth_service.py, message_service.py               │
│  - Реализация бизнес-правил                                     │
│  - Обработка транзакций                                         │
│  - Валидация бизнес-правил                                      │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│              MODELS LAYER (Модели данных / ORM)                 │
│  app/models/user.py, message.py, attachment.py                  │
│  - SQLAlchemy ORM модели                                        │
│  - Определение структуры БД                                      │
│  - Связи между сущностями                                       │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                    DATABASE LAYER                                │
│  app/database.py                                                 │
│  - Подключение к PostgreSQL                                     │
│  - Управление сессиями                                          │
│  - Миграции через Alembic                                       │
└─────────────────────────────────────────────────────────────────┘

Дополнительные слои:
- SCHEMAS LAYER (app/schemas/) - Pydantic схемы для валидации
- CORE LAYER (app/core/) - Конфигурация, безопасность, зависимости

1.3. Расположение компонентов
--------------------------------------------------------------------------------

КОНТРОЛЛЕРЫ / ОБРАБОТЧИКИ ЗАПРОСОВ:
├── app/api/endpoints/auth.py
│   ├── register() - регистрация пользователя
│   └── login() - вход в систему
│
└── app/api/endpoints/messages.py
    ├── get_inbox_messages() - получение входящих
    ├── get_sent_messages() - получение отправленных
    ├── get_message() - получение конкретного сообщения
    ├── create_message() - отправка сообщения
    ├── mark_message_as_read() - отметка прочтения
    └── delete_message() - удаление сообщения

МОДЕЛИ ДАННЫХ (ORM):
├── app/models/user.py
│   └── User - модель пользователя
│
├── app/models/message.py
│   └── Message - модель сообщения
│
└── app/models/attachment.py
    └── Attachment - модель вложения

СЕРВИСЫ / БИЗНЕС-ЛОГИКА:
├── app/services/auth_service.py
│   ├── register_user() - регистрация с проверками
│   ├── authenticate_user() - аутентификация
│   └── create_token_for_user() - создание JWT токена
│
└── app/services/message_service.py
    ├── create_message() - создание с валидацией получателя
    ├── get_inbox_messages() - получение входящих с фильтрами
    ├── get_sent_messages() - получение отправленных
    ├── get_message_by_id() - получение с проверкой прав доступа
    ├── mark_as_read() - отметка прочтения (только получатель)
    └── delete_message() - мягкое удаление

РЕПОЗИТОРИИ / РАБОТА С БД:
- SQLAlchemy ORM используется напрямую в сервисах
- app/database.py - настройка подключения и сессий
- get_db() - dependency для получения сессии БД
- Используется паттерн Unit of Work через SQLAlchemy Session

ВАЛИДАЦИЯ ДАННЫХ (SCHEMAS):
├── app/schemas/user.py
│   ├── UserCreate - схема регистрации
│   └── UserResponse - схема ответа
│
├── app/schemas/message.py
│   ├── MessageCreate - схема создания сообщения
│   ├── MessageResponse - схема ответа
│   └── AttachmentCreate/Response - схемы вложений
│
└── app/schemas/token.py
    └── Token - схема JWT токена

КОНФИГУРАЦИЯ И БЕЗОПАСНОСТЬ:
├── app/core/config.py - настройки приложения
├── app/core/security.py - JWT и хеширование паролей
└── app/core/dependencies.py - зависимости FastAPI (get_current_user)


2. СЕРВЕРНАЯ ЧАСТЬ
================================================================================

2.1. Основные модули и их назначение
--------------------------------------------------------------------------------

app/main.py
- Точка входа приложения
- Инициализация FastAPI приложения
- Настройка CORS middleware
- Глобальные обработчики исключений
- Подключение роутеров

app/api/main.py
- Главный роутер API
- Объединение всех эндпоинтов
- Префикс /api для всех маршрутов

app/database.py
- Настройка подключения к PostgreSQL
- Создание engine с пулом соединений
- SessionLocal для создания сессий
- get_db() - dependency injection для сессий

app/core/config.py
- Класс Settings с настройками
- Чтение переменных окружения
- Настройки БД, JWT, проекта

app/core/security.py
- verify_password() - проверка пароля (bcrypt)
- get_password_hash() - хеширование пароля
- create_access_token() - создание JWT
- decode_access_token() - декодирование JWT

app/core/dependencies.py
- get_current_user() - получение пользователя из JWT
- get_current_active_user() - проверка активности
- OAuth2PasswordBearer для аутентификации

2.2. Ключевые модели данных (сущности)
--------------------------------------------------------------------------------

2.2.1. User (Пользователь)
Файл: app/models/user.py

Поля:
- id: Integer (PK) - уникальный идентификатор
- username: String(50) - имя пользователя (уникальное, индексированное)
- email: String(100) - email (уникальный, индексированный)
- hashed_password: String(255) - хешированный пароль (bcrypt)
- is_active: Boolean - флаг активности аккаунта
- created_at: DateTime - дата создания (автоматически)
- updated_at: DateTime - дата обновления (автоматически)

Связи:
- sent_messages: Relationship -> Message (отправленные сообщения)
- received_messages: Relationship -> Message (полученные сообщения)

Особенности:
- Уникальные индексы на username и email
- Автоматическое логирование времени создания/обновления

2.2.2. Message (Сообщение)
Файл: app/models/message.py

Поля:
- id: Integer (PK) - уникальный идентификатор
- sender_id: Integer (FK -> users.id) - ID отправителя (индексирован)
- recipient_id: Integer (FK -> users.id) - ID получателя (индексирован)
- subject: String(200) - тема сообщения (обязательно)
- body: Text - текст сообщения (обязательно)
- is_read: Boolean - флаг прочтения (индексирован, default=False)
- is_deleted_by_sender: Boolean - мягкое удаление отправителем
- is_deleted_by_recipient: Boolean - мягкое удаление получателем
- created_at: DateTime - дата создания (индексирован, автоматически)
- read_at: DateTime - дата прочтения (nullable)

Связи:
- sender: Relationship -> User (отправитель)
- recipient: Relationship -> User (получатель)
- attachments: Relationship -> Attachment (вложения, cascade delete)

Индексы (оптимизация):
- idx_recipient_read: (recipient_id, is_read) - для быстрого поиска непрочитанных
- idx_sender_created: (sender_id, created_at) - для сортировки отправленных

Особенности:
- Мягкое удаление (soft delete) - сообщение скрывается для одного пользователя
- Отдельные флаги удаления для отправителя и получателя
- Индексы для оптимизации частых запросов

2.2.3. Attachment (Вложение)
Файл: app/models/attachment.py

Поля:
- id: Integer (PK) - уникальный идентификатор
- message_id: Integer (FK -> messages.id, CASCADE) - ID сообщения
- attachment_type: String(50) - тип вложения ('item', 'currency', 'gold', etc.)
- item_id: Integer (nullable) - ID игрового предмета
- item_name: String(200) (nullable) - название предмета
- quantity: Numeric(10, 2) - количество (default=1.0)
- attachment_data: JSON (nullable) - дополнительные данные в JSON формате

Связи:
- message: Relationship -> Message (родительское сообщение)

Особенности:
- Гибкая структура для различных типов игровых объектов
- JSON поле для хранения произвольных метаданных
- CASCADE удаление при удалении сообщения

2.3. Список основных API эндпоинтов
--------------------------------------------------------------------------------

2.3.1. Аутентификация (/api/auth)

POST /api/auth/register
- Регистрация нового пользователя
- Тело: {username, email, password}
- Ответ: UserResponse (201 Created)
- Ошибки: 400 (пользователь существует), 422 (валидация)

POST /api/auth/login
- Вход в систему (OAuth2 форма)
- Параметры: username, password (form-data)
- Ответ: {access_token, token_type} (200 OK)
- Ошибки: 401 (неверные данные)

2.3.2. Сообщения (/api/messages)
Все эндпоинты требуют аутентификации (Bearer token)

GET /api/messages
- Получение входящих сообщений
- Параметры: skip (int), limit (int, 1-100), unread_only (bool)
- Ответ: List[MessageResponse] (200 OK)

GET /api/messages/sent
- Получение отправленных сообщений
- Параметры: skip (int), limit (int, 1-100)
- Ответ: List[MessageResponse] (200 OK)

GET /api/messages/{message_id}
- Получение конкретного сообщения
- Ответ: MessageResponse (200 OK)
- Ошибки: 404 (не найдено), 403 (нет доступа)

POST /api/messages
- Отправка нового сообщения
- Тело: {recipient_id, subject, body, attachments[]}
- Ответ: MessageResponse (201 Created)
- Ошибки: 404 (получатель не найден), 400 (неактивный получатель)

PATCH /api/messages/{message_id}/read
- Отметка сообщения как прочитанного
- Только для получателя
- Ответ: MessageResponse (200 OK)
- Ошибки: 403 (не получатель), 404 (не найдено)

DELETE /api/messages/{message_id}
- Мягкое удаление сообщения
- Ответ: 204 No Content
- Ошибки: 404 (не найдено)

2.3.3. Системные эндпоинты

GET /
- Информация об API
- Ответ: {message, version, docs} (200 OK)

GET /health
- Проверка работоспособности
- Ответ: {status: "healthy"} (200 OK)


3. ЧТО ТЕСТИРОВАТЬ
================================================================================

3.1. Ключевые функции/методы для unit-тестирования
--------------------------------------------------------------------------------

3.1.1. AuthService (app/services/auth_service.py)

register_user()
- Успешная регистрация нового пользователя
- Ошибка при дублировании username
- Ошибка при дублировании email
- Обработка IntegrityError (race condition)
- Хеширование пароля

authenticate_user()
- Успешная аутентификация с правильными данными
- Ошибка при неверном username
- Ошибка при неверном password
- Ошибка при неактивном пользователе

create_token_for_user()
- Создание валидного JWT токена
- Содержание username в payload
- Срок действия токена

3.1.2. MessageService (app/services/message_service.py)

create_message()
- Успешное создание сообщения
- Создание сообщения с вложениями
- Ошибка при несуществующем получателе
- Ошибка при неактивном получателе
- Транзакционность (rollback при ошибке)

get_inbox_messages()
- Получение всех входящих сообщений
- Фильтрация по unread_only
- Пагинация (skip, limit)
- Исключение удаленных сообщений
- Сортировка по дате (desc)

get_sent_messages()
- Получение всех отправленных сообщений
- Пагинация
- Исключение удаленных сообщений

get_message_by_id()
- Получение сообщения отправителем
- Получение сообщения получателем
- Ошибка при отсутствии доступа
- Ошибка при удаленном сообщении
- Ошибка при несуществующем сообщении

mark_as_read()
- Успешная отметка прочтения
- Ошибка при попытке отправителя
- Обновление read_at
- Идемпотентность (повторный вызов)

delete_message()
- Мягкое удаление для отправителя
- Мягкое удаление для получателя
- Сохранение для другого участника

3.1.3. Security (app/core/security.py)

verify_password()
- Проверка правильного пароля
- Проверка неправильного пароля
- Обработка ошибок

get_password_hash()
- Хеширование пароля
- Проверка ограничения 72 байта
- Обработка Unicode символов
- Обработка пустого пароля

create_access_token()
- Создание токена с данными
- Срок действия токена
- Алгоритм подписи

decode_access_token()
- Декодирование валидного токена
- Ошибка при невалидном токене
- Ошибка при истекшем токене

3.1.4. Dependencies (app/core/dependencies.py)

get_current_user()
- Получение пользователя из валидного токена
- Ошибка при невалидном токене
- Ошибка при отсутствии пользователя
- Ошибка при неактивном пользователе

3.2. Интеграционное тестирование - ключевые сценарии
--------------------------------------------------------------------------------

3.2.1. Сценарий регистрации и входа
1. Регистрация нового пользователя
2. Попытка регистрации с дублирующим username (ошибка)
3. Попытка регистрации с дублирующим email (ошибка)
4. Успешный вход с правильными данными
5. Попытка входа с неверным паролем (ошибка)
6. Получение JWT токена

3.2.2. Сценарий отправки и получения сообщений
1. Регистрация двух пользователей (A и B)
2. Вход пользователя A
3. Отправка сообщения от A к B (с вложениями)
4. Вход пользователя B
5. Получение входящих сообщений B (должно содержать сообщение от A)
6. Получение конкретного сообщения B
7. Отметка сообщения как прочитанного B
8. Получение отправленных сообщений A

3.2.3. Сценарий мягкого удаления
1. Отправка сообщения от A к B
2. Удаление сообщения пользователем B
3. Проверка: B не видит сообщение
4. Проверка: A все еще видит сообщение в отправленных
5. Удаление сообщения пользователем A
6. Проверка: A не видит сообщение
7. Проверка: B все еще видит сообщение (если не удалил)

3.2.4. Сценарий пагинации
1. Создание 25 сообщений
2. Запрос первой страницы (limit=10, skip=0) - должно вернуть 10
3. Запрос второй страницы (limit=10, skip=10) - должно вернуть 10
4. Запрос третьей страницы (limit=10, skip=20) - должно вернуть 5
5. Проверка сортировки по дате (desc)

3.2.5. Сценарий фильтрации непрочитанных
1. Отправка 5 сообщений от A к B
2. Отметка 2 сообщений как прочитанных
3. Запрос всех входящих - должно вернуть 5
4. Запрос только непрочитанных - должно вернуть 3

3.2.6. Сценарий вложений
1. Отправка сообщения с вложением типа "item"
2. Отправка сообщения с вложением типа "gold"
3. Отправка сообщения с несколькими вложениями
4. Проверка сохранения attachment_data (JSON)
5. Проверка каскадного удаления вложений

3.2.7. Сценарий безопасности
1. Попытка доступа к эндпоинту без токена (401)
2. Попытка доступа с невалидным токеном (401)
3. Попытка доступа к чужому сообщению (403)
4. Попытка отметить чужое сообщение как прочитанное (403)
5. Попытка отправить сообщение несуществующему пользователю (404)
6. Попытка отправить сообщение неактивному пользователю (400)

3.2.8. Сценарий производительности
1. Создание 1000 сообщений
2. Измерение времени запроса входящих с пагинацией
3. Проверка использования индексов (EXPLAIN ANALYZE)
4. Проверка работы пула соединений


4. УНИКАЛЬНОСТЬ ПРОЕКТА
================================================================================

4.1. Особенности по сравнению с типовыми решениями
--------------------------------------------------------------------------------

4.1.1. Система вложений для игровых объектов
- Гибкая структура Attachment с поддержкой различных типов (item, currency, gold)
- JSON поле attachment_data для хранения произвольных метаданных игровых предметов
- Поддержка множественных вложений в одном сообщении
- Типизация через attachment_type для различных игровых сущностей

Отличие от типовых почтовых систем:
- Обычные почтовые системы работают с файлами/медиа
- Данная система оптимизирована для игровых объектов с метаданными

4.1.2. Двустороннее мягкое удаление (Soft Delete)
- Отдельные флаги is_deleted_by_sender и is_deleted_by_recipient
- Сообщение остается доступным для другого участника переписки
- Сохранение истории переписки для каждого пользователя независимо

Отличие от типовых решений:
- Обычно soft delete скрывает запись для всех
- Здесь реализована персональная история для каждого пользователя

4.1.3. Оптимизация запросов через составные индексы
- idx_recipient_read: (recipient_id, is_read) - для быстрого поиска непрочитанных
- idx_sender_created: (sender_id, created_at) - для сортировки отправленных
- Индексы на часто используемых полях (sender_id, recipient_id, is_read, created_at)

Отличие:
- Многие проекты не используют составные индексы для оптимизации
- Здесь индексы спроектированы под конкретные паттерны запросов

4.1.4. Валидация пароля с учетом UTF-8 байтов
- Проверка длины пароля в байтах (ограничение bcrypt: 72 байта)
- Учет того, что Unicode символы могут занимать несколько байт
- Детальные сообщения об ошибках с указанием длины в символах и байтах

Отличие:
- Типичные валидации проверяют только длину в символах
- Здесь учтено реальное ограничение библиотеки хеширования

4.1.5. Разделение ответственности через Service Layer
- Вся бизнес-логика вынесена в сервисы
- Эндпоинты только обрабатывают HTTP запросы/ответы
- Легкость тестирования бизнес-логики без HTTP слоя

Отличие:
- Многие FastAPI проекты размещают логику прямо в эндпоинтах
- Здесь четкое разделение на слои

4.1.6. Обработка транзакций при создании сообщений
- Использование flush() для получения ID перед созданием вложений
- Атомарность операции (rollback при ошибке)
- Каскадное удаление вложений при удалении сообщения

4.1.7. Глобальная обработка исключений
- Централизованные обработчики для всех типов ошибок
- Логирование с контекстом (path, method)
- Разные уровни детализации для DEBUG и production

4.2. Технические решения
--------------------------------------------------------------------------------

- FastAPI для современного async/await API
- SQLAlchemy 2.0 с type hints
- Pydantic v2 для валидации
- JWT аутентификация по стандарту OAuth2
- Alembic для версионирования схемы БД
- Docker для контейнеризации
- PostgreSQL как надежная реляционная БД


5. ДОКУМЕНТАЦИЯ
================================================================================

5.1. Схемы/таблицы для документации
--------------------------------------------------------------------------------

5.1.1. ER-диаграмма базы данных

users (Пользователи)
├── id (PK, Integer)
├── username (String(50), UNIQUE, INDEX)
├── email (String(100), UNIQUE, INDEX)
├── hashed_password (String(255))
├── is_active (Boolean, default=True)
├── created_at (DateTime, auto)
└── updated_at (DateTime, auto)

messages (Сообщения)
├── id (PK, Integer)
├── sender_id (FK -> users.id, INDEX)
├── recipient_id (FK -> users.id, INDEX)
├── subject (String(200))
├── body (Text)
├── is_read (Boolean, default=False, INDEX)
├── is_deleted_by_sender (Boolean, default=False)
├── is_deleted_by_recipient (Boolean, default=False)
├── created_at (DateTime, auto, INDEX)
└── read_at (DateTime, nullable)

attachments (Вложения)
├── id (PK, Integer)
├── message_id (FK -> messages.id, CASCADE, INDEX)
├── attachment_type (String(50))
├── item_id (Integer, nullable)
├── item_name (String(200), nullable)
├── quantity (Numeric(10, 2), default=1.0)
└── attachment_data (JSON, nullable)

Составные индексы:
- idx_recipient_read: (recipient_id, is_read)
- idx_sender_created: (sender_id, created_at)

Связи:
- users 1:N messages (sent_messages)
- users 1:N messages (received_messages)
- messages 1:N attachments (CASCADE DELETE)

5.1.2. Диаграмма архитектуры (можно в виде текста или ASCII)

┌─────────────┐
│   Client    │
└──────┬──────┘
       │ HTTP/HTTPS
       ↓
┌─────────────────────────────────────┐
│         FastAPI Application         │
│  ┌───────────────────────────────┐  │
│  │   API Endpoints (Controllers) │  │
│  │  - auth.py                    │  │
│  │  - messages.py                │  │
│  └───────────┬───────────────────┘  │
│              ↓                       │
│  ┌───────────────────────────────┐  │
│  │   Services (Business Logic)   │  │
│  │  - auth_service.py            │  │
│  │  - message_service.py         │  │
│  └───────────┬───────────────────┘  │
│              ↓                       │
│  ┌───────────────────────────────┐  │
│  │   Models (SQLAlchemy ORM)    │  │
│  │  - User, Message, Attachment │  │
│  └───────────┬───────────────────┘  │
└──────────────┼───────────────────────┘
               ↓
┌─────────────────────────────────────┐
│         PostgreSQL Database         │
│  - users                            │
│  - messages                         │
│  - attachments                      │
└─────────────────────────────────────┘

5.2. Техническая конкретика для документации
--------------------------------------------------------------------------------

5.2.1. Технологический стек
- Python 3.11+
- FastAPI 0.104.1
- SQLAlchemy 2.0.23
- PostgreSQL (любая версия 12+)
- Alembic 1.12.1
- Pydantic 2.5.0
- python-jose[cryptography] 3.3.0
- passlib[bcrypt] 1.7.4
- uvicorn[standard] 0.24.0

5.2.2. Конфигурация
Переменные окружения (.env):
- DATABASE_URL - строка подключения к PostgreSQL
- SECRET_KEY - секретный ключ для JWT (минимум 32 символа)
- ALGORITHM - алгоритм подписи JWT (по умолчанию HS256)
- ACCESS_TOKEN_EXPIRE_MINUTES - срок действия токена (по умолчанию 30)
- DEBUG - режим отладки (True/False)
- PROJECT_NAME - название проекта

5.2.3. Структура JWT токена
Header:
{
  "alg": "HS256",
  "typ": "JWT"
}

Payload:
{
  "sub": "username",  // subject (имя пользователя)
  "exp": 1234567890   // expiration time (Unix timestamp)
}

5.2.4. Формат вложений (Attachment)
Примеры типов:
- "item" - игровой предмет
- "currency" - игровая валюта
- "gold" - золото

Пример attachment_data для предмета:
{
  "rarity": "epic",
  "level": 10,
  "damage": 150,
  "type": "weapon"
}

5.2.5. Ограничения и валидация
- username: 3-50 символов, уникальный
- email: валидный email формат, уникальный
- password: минимум 6 символов, максимум 72 байта в UTF-8
- subject: 1-200 символов
- body: минимум 1 символ
- limit (пагинация): 1-100 записей
- quantity (вложение): >= 0, Numeric(10,2)

5.2.6. Коды HTTP статусов
- 200 OK - успешный запрос
- 201 Created - ресурс создан
- 204 No Content - успешное удаление
- 400 Bad Request - неверный запрос
- 401 Unauthorized - требуется аутентификация
- 403 Forbidden - нет доступа
- 404 Not Found - ресурс не найден
- 422 Unprocessable Entity - ошибка валидации
- 500 Internal Server Error - внутренняя ошибка

5.2.7. Паттерны проектирования
- Dependency Injection (через FastAPI Depends)
- Repository Pattern (через SQLAlchemy ORM)
- Service Layer Pattern
- Factory Pattern (для создания токенов)
- Strategy Pattern (для различных типов вложений)

5.2.8. Безопасность
- Пароли хешируются через bcrypt (cost factor по умолчанию)
- JWT токены с истечением срока действия
- Валидация всех входных данных через Pydantic
- Проверка прав доступа на уровне сервисов
- Защита от SQL injection через ORM
- CORS настройки (в production указать конкретные домены)

5.2.9. Производительность
- Пул соединений к БД (pool_pre_ping, pool_recycle)
- Индексы на часто запрашиваемых полях
- Составные индексы для оптимизации запросов
- Пагинация для больших списков
- Ленивая загрузка связей (lazy loading)

5.2.10. Миграции базы данных
- Использование Alembic для версионирования схемы
- Автогенерация миграций: alembic revision --autogenerate
- Применение: alembic upgrade head
- Откат: alembic downgrade -1


6. СТРУКТУРА ОПИСАНИЯ ДЛЯ КУРСОВОЙ РАБОТЫ
================================================================================

6.1. Рекомендуемая структура документа
--------------------------------------------------------------------------------

1. ВВЕДЕНИЕ
   1.1. Актуальность темы
   1.2. Цель и задачи работы
   1.3. Объект и предмет исследования

2. АНАЛИЗ СУЩЕСТВУЮЩИХ РЕШЕНИЙ
   2.1. Обзор систем внутриигровой коммуникации
   2.2. Сравнительный анализ технологий
   2.3. Выбор технологического стека

3. ПРОЕКТИРОВАНИЕ СИСТЕМЫ
   3.1. Архитектура системы
       3.1.1. Выбор архитектурного подхода
       3.1.2. Описание слоев архитектуры
       3.1.3. Диаграмма архитектуры
   3.2. Проектирование базы данных
       3.2.1. ER-диаграмма
       3.2.2. Описание сущностей
       3.2.3. Связи между сущностями
       3.2.4. Индексы и оптимизация
   3.3. Проектирование API
       3.3.1. RESTful принципы
       3.3.2. Структура эндпоинтов
       3.3.3. Схемы данных (Pydantic)

4. РЕАЛИЗАЦИЯ СИСТЕМЫ
   4.1. Реализация слоя данных
       4.1.1. Модели ORM (SQLAlchemy)
       4.1.2. Миграции базы данных
   4.2. Реализация бизнес-логики
       4.2.1. Сервис аутентификации
       4.2.2. Сервис работы с сообщениями
   4.3. Реализация API слоя
       4.3.1. Эндпоинты аутентификации
       4.3.2. Эндпоинты сообщений
       4.3.3. Обработка ошибок
   4.4. Безопасность
       4.4.1. Хеширование паролей
       4.4.2. JWT аутентификация
       4.4.3. Валидация данных

5. ТЕСТИРОВАНИЕ
   5.1. Unit-тестирование
       5.1.1. Тестирование сервисов
       5.1.2. Тестирование безопасности
   5.2. Интеграционное тестирование
       5.2.1. Сценарии использования
       5.2.2. Тестирование API
   5.3. Результаты тестирования

6. УНИКАЛЬНЫЕ ОСОБЕННОСТИ РЕАЛИЗАЦИИ
   6.1. Система вложений для игровых объектов
   6.2. Двустороннее мягкое удаление
   6.3. Оптимизация запросов
   6.4. Валидация с учетом UTF-8

7. ЗАКЛЮЧЕНИЕ
   7.1. Достигнутые результаты
   7.2. Перспективы развития

ПРИЛОЖЕНИЯ
   A. Листинги ключевых модулей
   B. Примеры запросов и ответов API
   C. Конфигурационные файлы
   D. ER-диаграмма (графическая)

6.2. Ключевые моменты для описания
--------------------------------------------------------------------------------

В разделе "Архитектура":
- Подчеркнуть использование слоистой архитектуры
- Описать разделение ответственности между слоями
- Показать использование Dependency Injection
- Упомянуть паттерны проектирования

В разделе "Реализация":
- Привести примеры кода ключевых методов
- Описать логику работы с транзакциями
- Показать обработку ошибок
- Описать валидацию данных

В разделе "Уникальность":
- Детально описать систему вложений
- Объяснить логику мягкого удаления
- Показать оптимизацию через индексы
- Описать валидацию паролей

В разделе "Тестирование":
- Описать покрытие unit-тестами
- Привести примеры интеграционных тестов
- Показать тестирование безопасности
- Упомянуть производительность

6.3. Типичные ошибки, которых следует избегать
--------------------------------------------------------------------------------

❌ НЕ ДЕЛАТЬ:
- Описывать архитектуру как "MVC" (это не MVC, это слоистая)
- Говорить "просто REST API" без деталей
- Не упоминать про индексы и оптимизацию
- Игнорировать безопасность в описании
- Не описывать уникальные особенности проекта

✅ ДЕЛАТЬ:
- Четко описать слои и их назначение
- Показать ER-диаграмму с индексами
- Описать бизнес-логику в сервисах
- Упомянуть обработку транзакций
- Подчеркнуть уникальные решения (вложения, мягкое удаление)
- Описать валидацию и безопасность
- Привести примеры кода
- Показать структуру проекта

6.4. Рекомендации по оформлению
--------------------------------------------------------------------------------

- Использовать диаграммы (ASCII или графические)
- Приводить примеры кода с комментариями
- Показывать примеры запросов/ответов API
- Использовать таблицы для сравнения
- Включить скриншоты Swagger UI
- Привести метрики производительности (если есть)
- Показать покрытие тестами (если есть)


================================================================================
КОНЕЦ ДОКУМЕНТА
================================================================================

